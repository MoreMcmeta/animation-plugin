package io.github.moremcmeta.animationplugin.metadata;

import com.mojang.datafixers.util.Pair;
import io.github.moremcmeta.animationplugin.animate.AnimationComponent;
import io.github.moremcmeta.animationplugin.animate.AnimationGroupComponent;
import io.github.moremcmeta.animationplugin.animate.DefaultAlphaInterpolator;
import io.github.moremcmeta.animationplugin.animate.Frame;
import io.github.moremcmeta.animationplugin.animate.Interpolator;
import io.github.moremcmeta.animationplugin.animate.SmoothAlphaInterpolator;
import io.github.moremcmeta.animationplugin.animate.WobbleFunction;
import io.github.moremcmeta.moremcmeta.api.client.metadata.AnalyzedMetadata;
import io.github.moremcmeta.moremcmeta.api.client.texture.Color;
import io.github.moremcmeta.moremcmeta.api.client.texture.ComponentBuilder;
import io.github.moremcmeta.moremcmeta.api.client.texture.CurrentFrameView;
import io.github.moremcmeta.moremcmeta.api.client.texture.FrameGroup;
import io.github.moremcmeta.moremcmeta.api.client.texture.MutableFrameView;
import io.github.moremcmeta.moremcmeta.api.client.texture.TextureComponent;
import io.github.moremcmeta.moremcmeta.api.math.Area;
import io.github.moremcmeta.moremcmeta.api.math.Point;
import it.unimi.dsi.fastutil.ints.IntIntPair;
import net.minecraft.client.multiplayer.ClientLevel;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.IntUnaryOperator;
import java.util.function.Supplier;

import static java.util.Objects.requireNonNull;

/**
 * Generates {@link AnimationComponent}s from {@link AnimationMetadata}.
 * @author soir20
 */
public class AnimationComponentBuilder implements ComponentBuilder {
    private static final int TICKS_PER_DAY = 24000;
    private static final WobbleFunction WOBBLE_FUNCTION = new WobbleFunction();

    private final Supplier<Optional<ClientLevel>> LEVEL_SUPPLIER;

    /**
     * Creates a new animation component builder.
     * @param levelSupplier     supplies the
     */
    public AnimationComponentBuilder(Supplier<Optional<ClientLevel>> levelSupplier) {
        LEVEL_SUPPLIER = requireNonNull(levelSupplier, "Level supplier cannot be null");
    }

    @Override
    public TextureComponent<? super CurrentFrameView>
    build(AnalyzedMetadata metadata, FrameGroup<? extends MutableFrameView> baseFrames) {
        requireNonNull(metadata, "Metadata cannot be null");
        requireNonNull(baseFrames, "Frame group cannot be null");

        // This cast is guaranteed to work since the metadata object is the same as was generated by the parser
        if (!(metadata instanceof AnimationGroupMetadata animationGroupMetadata)) {
            throw new IllegalArgumentException("Metadata provided to animation component builder is not animation " +
                    "metadata. Something is wrong with the core MoreMcmeta mod.");
        }

        // Run larger animations first, then the leftmost, then the topmost
        List<AnimationMetadata> sortedAnimations = animationGroupMetadata.parts().stream()
                .sorted(
                        Comparator.comparingInt((AnimationMetadata anim) -> -1 * anim.frameWidth() * anim.frameHeight())
                                .thenComparing(AnimationMetadata::xInBase)
                                .thenComparing(AnimationMetadata::yInBase)
                )
                .toList();

        // Ensure non-changing areas of parts are written to texture
        sortedAnimations.forEach((animation) -> animation.partFrames().ifPresent((frames) -> {
            Frame firstPartFrame = frames.get(0);
            int xInBase = animation.xInBase();
            int yInBase = animation.yInBase();

            for (int baseIndex = 0; baseIndex < baseFrames.frames(); baseIndex++) {
                baseFrames.frame(baseIndex).transform(
                        (x, y, layerBelow) -> firstPartFrame.color(x - xInBase, y - yInBase),
                        new Area(xInBase, yInBase, animation.frameWidth(), animation.frameHeight())
                );
            }
        }));

        List<Pair<AnimationComponent, Optional<List<Frame>>>> components = sortedAnimations.stream()
                .map((animation) -> Pair.of(buildComponent(animation, baseFrames), animation.partFrames()))
                .toList();

        return new AnimationGroupComponent(
                components,
                sortedAnimations.stream().<Runnable>map((animation) -> animation::close).toList()
        );
    }

    /**
     * Retrieves data from animation metadata to build an animation component.
     * @param animationMetadata     animation metadata to use for the component
     * @param baseFrames            frames in the base texture
     * @return built component
     */
    private AnimationComponent buildComponent(AnimationMetadata animationMetadata,
                                              FrameGroup<? extends MutableFrameView> baseFrames) {
        List<Frame> frames = animationMetadata.partFrames().orElse(wrapFrames(baseFrames));

        Area changedArea = findChangedArea(
                frames,
                animationMetadata.frameWidth(),
                animationMetadata.frameHeight(),
                animationMetadata.xInBase(),
                animationMetadata.yInBase()
        );

        List<IntIntPair> predefinedFrames = animationMetadata.predefinedFrames();

        // Number of frames
        int frameCount = frames.size();
        if (!predefinedFrames.isEmpty()) {
            frameCount = predefinedFrames.size();
        }

        // Frame time calculation
        IntUnaryOperator frameTimeCalculator = (index) -> {
            if (predefinedFrames.isEmpty()) {
                return animationMetadata.defaultTime();
            }

            return predefinedFrames.get(index).rightInt();
        };

        // Index mapping
        IntUnaryOperator frameIndexMapper = (index) -> {
            if (predefinedFrames.isEmpty()) {
                return index;
            }

            return predefinedFrames.get(index).leftInt();
        };

        // Time retrieval
        Supplier<Optional<Long>> timeGetter = () -> {
            Optional<ClientLevel> levelOptional = LEVEL_SUPPLIER.get();
            if (levelOptional.isEmpty()) {
                return Optional.empty();
            }

            ClientLevel level = levelOptional.get();
            long time = WOBBLE_FUNCTION.calculate(level.dayTime(), level.getGameTime(), level.dimensionType().natural());
            return Optional.of(time);
        };

        Interpolator interpolator;
        if (!animationMetadata.interpolate()) {
            interpolator = (steps, step, start, end) -> start;
        } else if (animationMetadata.smoothAlpha()) {
            interpolator = new SmoothAlphaInterpolator();
        } else {
            interpolator = new DefaultAlphaInterpolator();
        }

        AnimationComponent.Builder componentBuilder = new AnimationComponent.Builder();
        componentBuilder.interpolateArea(changedArea)
                .frames(frameCount)
                .ticksUntilStart(animationMetadata.skipTicks())
                .frameTimeCalculator(frameTimeCalculator)
                .frameIndexMapper(frameIndexMapper)
                .interpolator(interpolator)
                .coordinateInBase(animationMetadata.xInBase(), animationMetadata.yInBase());

        if (animationMetadata.daytimeSync()) {
            componentBuilder.syncTicks(TICKS_PER_DAY, timeGetter);
        }

        return componentBuilder.build();
    }

    /**
     * Wraps {@link MutableFrameView}s to be compatible with the {@link Frame} interface.
     * @param frames    frames to wrap
     * @return wrapped frames
     */
    private static List<Frame> wrapFrames(FrameGroup<? extends MutableFrameView> frames) {
        List<Frame> wrappedFrames = new ArrayList<>();
        for (int index = 0; index < frames.frames(); index++) {
            final int finalIndex = index;
            wrappedFrames.add((x, y) -> {
                AtomicInteger color = new AtomicInteger();

                frames.frame(finalIndex).transform(
                        (overwriteX, overwriteY, layerBelow) -> {
                            int existingColor = layerBelow.color(overwriteX, overwriteY);
                            color.set(existingColor);
                            return existingColor;
                        },
                        Area.of(Point.pack(x, y))
                );

                return color.get();
            });
        }

        return wrappedFrames;
    }

    /**
     * Gets the pixels that will change throughout the animation. If the image
     * is empty, an empty area will be returned.
     * @param frames        frames to analyze
     * @param frameWidth    width of a frame in the animation
     * @param frameHeight   height of a frame in the animation
     * @param xInBase       x-coordinate of the top-left corner of this animation within the base texture
     * @param yInBase       y-coordinate of the top-left corner of this animation within the base texture
     * @return area representing pixels that change throughout the animation
     */
    private static Area findChangedArea(List<Frame> frames, int frameWidth, int frameHeight, int xInBase, int yInBase) {
        requireNonNull(frames, "Image cannot be null");
        if (frames.size() == 0) {
            return Area.of();
        }

        Frame firstFrame = frames.get(0);
        Area fullFrameArea = new Area(0, 0, frameWidth, frameHeight);
        Area.Builder areaBuilder = new Area.Builder();

        // For every point in the first frame, check that point in the other frames
        for (long point : fullFrameArea) {
            int x = Point.x(point);
            int y = Point.y(point);
            int firstColor = firstFrame.color(x, y);

            // Check the point in each of the other frames
            for (int frameIndex = 1; frameIndex < frames.size(); frameIndex++) {
                int otherColor = frames.get(frameIndex).color(x, y);
                if (!Color.equalsOrBothInvisible(firstColor, otherColor)) {
                    areaBuilder.addPixel(x + xInBase, y + yInBase);
                    break;
                }

            }
        }

        return areaBuilder.build();
    }

}
