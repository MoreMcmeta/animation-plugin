package io.github.moremcmeta.animationplugin;

import io.github.moremcmeta.moremcmeta.api.client.metadata.ParsedMetadata;
import io.github.moremcmeta.moremcmeta.api.client.texture.Color;
import io.github.moremcmeta.moremcmeta.api.client.texture.ComponentProvider;
import io.github.moremcmeta.moremcmeta.api.client.texture.CurrentFrameView;
import io.github.moremcmeta.moremcmeta.api.client.texture.FrameGroup;
import io.github.moremcmeta.moremcmeta.api.client.texture.MutableFrameView;
import io.github.moremcmeta.moremcmeta.api.client.texture.TextureComponent;
import io.github.moremcmeta.moremcmeta.api.client.texture.UploadableFrameView;
import io.github.moremcmeta.moremcmeta.api.math.Area;
import net.minecraft.client.multiplayer.ClientLevel;

import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.IntUnaryOperator;
import java.util.function.Supplier;

import static java.util.Objects.requireNonNull;

/**
 * Generates {@link AnimationComponent}s from {@link AnimationMetadata}.
 * @author soir20
 */
public class AnimationComponentProvider implements ComponentProvider {
    private static final int TICKS_PER_DAY = 24000;
    private static final WobbleFunction WOBBLE_FUNCTION = new WobbleFunction();

    private final Supplier<Optional<ClientLevel>> LEVEL_SUPPLIER;

    /**
     * Creates a new animation component provider.
     * @param levelSupplier     supplies the
     */
    public AnimationComponentProvider(Supplier<Optional<ClientLevel>> levelSupplier) {
        LEVEL_SUPPLIER = requireNonNull(levelSupplier, "Level supplier cannot be null");
    }

    @Override
    public TextureComponent<CurrentFrameView, UploadableFrameView>
    assemble(ParsedMetadata metadata, FrameGroup<? extends MutableFrameView> frames) {
        requireNonNull(metadata, "Metadata cannot be null");
        requireNonNull(frames, "Frame group cannot be null");

        // This cast is guaranteed to work since the metadata object is the same as was generated by the parser
        if (!(metadata instanceof AnimationMetadata animationMetadata)) {
            throw new IllegalArgumentException("Metadata provided to animation component provider is not animation " +
                    "metadata. Something is wrong with the core MoreMcmeta mod.");
        }

        Area changedArea = animationMetadata.interpolate() ? findChangedArea(frames) : Area.of();

        // Frame time calculation
        IntUnaryOperator frameTimeCalculator = (index) -> {
            if (animationMetadata.predefinedFrames().isEmpty()) {
                return animationMetadata.defaultTime();
            }

            return animationMetadata.predefinedFrames().get(index).rightInt();
        };

        // Time retrieval
        Supplier<Optional<Long>> timeGetter = () -> {
            Optional<ClientLevel> levelOptional = LEVEL_SUPPLIER.get();
            if (levelOptional.isEmpty()) {
                return Optional.empty();
            }

            ClientLevel level = levelOptional.get();
            long time = WOBBLE_FUNCTION.calculate(level.dayTime(), level.getGameTime(), level.dimensionType().natural());
            return Optional.of(time);
        };

        Interpolator interpolator = new RGBAInterpolator();

        if (animationMetadata.daytimeSync()) {
            return new AnimationComponent(
                    changedArea,
                    frames.frames(),
                    frameTimeCalculator,
                    interpolator,
                    TICKS_PER_DAY,
                    timeGetter);
        }

        return new AnimationComponent(
                changedArea,
                frames.frames(),
                frameTimeCalculator,
                interpolator
        );
    }

    /**
     * Gets the pixels that will change throughout the animation. If the image
     * is empty, an empty area will be returned.
     * @param frames        frames to analyze
     * @return area representing pixels that change throughout the animation
     */
    private static Area findChangedArea(FrameGroup<? extends MutableFrameView> frames) {
        requireNonNull(frames, "Image cannot be null");
        if (frames.frames() == 0) {
            return Area.of();
        }

        MutableFrameView firstFrame = frames.frame(0);
        Area fullFrameArea = new Area(0, 0, firstFrame.width(), firstFrame.height());
        Area.Builder areaBuilder = new Area.Builder();

        // For every point in the first frame, check that point in the other frames
        firstFrame.transform(
                (overwritePoint, dependencyFunction) -> {
                    Color firstColor = dependencyFunction.apply(overwritePoint);

                    // Check the point in each of the other frames
                    AtomicBoolean isDifferent = new AtomicBoolean();
                    for (int frameIndex = 1; frameIndex < frames.frames(); frameIndex++) {
                        frames.frame(frameIndex).transform(
                                (otherOverwritePoint, otherDependencyFunction) -> {
                                    Color otherColor = otherDependencyFunction.apply(otherOverwritePoint);
                                    if (!firstColor.equalsOrBothInvisible(otherColor)) {
                                        areaBuilder.addPixel(overwritePoint);
                                        isDifferent.set(true);
                                    }

                                    return otherDependencyFunction.apply(otherOverwritePoint);
                                },
                                Area.of(overwritePoint),
                                Area.of(overwritePoint)
                        );

                        // If a different point is found, checking the other frames is unnecessary
                        if (isDifferent.get()) {
                            break;
                        }

                    }

                    return dependencyFunction.apply(overwritePoint);
                },
                fullFrameArea,
                fullFrameArea
        );

        return areaBuilder.build();
    }

}
