package io.github.moremcmeta.animationplugin;

import io.github.moremcmeta.moremcmeta.api.client.metadata.ParsedMetadata;
import io.github.moremcmeta.moremcmeta.api.client.texture.Color;
import io.github.moremcmeta.moremcmeta.api.client.texture.ComponentProvider;
import io.github.moremcmeta.moremcmeta.api.client.texture.CurrentFrameView;
import io.github.moremcmeta.moremcmeta.api.client.texture.FrameGroup;
import io.github.moremcmeta.moremcmeta.api.client.texture.MutableFrameView;
import io.github.moremcmeta.moremcmeta.api.client.texture.TextureComponent;
import io.github.moremcmeta.moremcmeta.api.client.texture.UploadableFrameView;
import io.github.moremcmeta.moremcmeta.api.math.Area;

import java.util.concurrent.atomic.AtomicBoolean;

import static java.util.Objects.requireNonNull;

/**
 * Generates {@link AnimationComponent}s from {@link AnimationMetadata}.
 * @author soir20
 */
public class AnimationComponentProvider implements ComponentProvider {

    @Override
    public TextureComponent<CurrentFrameView, UploadableFrameView>
    assemble(ParsedMetadata metadata, FrameGroup<? extends MutableFrameView> frames) {

        // This cast is guaranteed to work since the metadata object is the same as was generated by the parser
        AnimationMetadata animationMetadata = (AnimationMetadata) metadata;

        Area changedArea = animationMetadata.interpolate() ? findChangedArea(frames) : Area.of();

        return new AnimationComponent(
                changedArea,
                frames.frames(),
                (index) -> {
                    if (animationMetadata.predefinedFrames().isEmpty()) {
                        return animationMetadata.defaultTime();
                    }

                    return animationMetadata.predefinedFrames().get(index).rightInt();
                }
        );
    }

    /**
     * Gets the pixels that will change throughout the animation. If the image
     * is empty, an empty area will be returned.
     * @param frames        frames to analyze
     * @return area representing pixels that change throughout the animation
     */
    private static Area findChangedArea(FrameGroup<? extends MutableFrameView> frames) {
        requireNonNull(frames, "Image cannot be null");
        if (frames.frames() == 0) {
            return Area.of();
        }

        MutableFrameView firstFrame = frames.frame(0);
        Area fullFrameArea = new Area(0, 0, firstFrame.width(), firstFrame.height());
        Area.Builder areaBuilder = new Area.Builder();

        // For every point in the first frame, check that point in the other frames
        firstFrame.transform(
                (overwritePoint, dependencyFunction) -> {
                    Color firstColor = dependencyFunction.apply(overwritePoint);

                    // Check the point in each of the other frames
                    AtomicBoolean isDifferent = new AtomicBoolean();
                    for (int frameIndex = 1; frameIndex < frames.frames(); frameIndex++) {
                        frames.frame(frameIndex).transform(
                                (otherOverwritePoint, otherDependencyFunction) -> {
                                    Color otherColor = otherDependencyFunction.apply(otherOverwritePoint);
                                    if (!firstColor.equalsOrBothInvisible(otherColor)) {
                                        areaBuilder.addPixel(overwritePoint);
                                        isDifferent.set(true);
                                    }

                                    return otherDependencyFunction.apply(otherOverwritePoint);
                                },
                                Area.of(overwritePoint),
                                Area.of(overwritePoint)
                        );

                        // If a different point is found, checking the other frames is unnecessary
                        if (isDifferent.get()) {
                            break;
                        }

                    }

                    return dependencyFunction.apply(overwritePoint);
                },
                fullFrameArea,
                fullFrameArea
        );

        return areaBuilder.build();
    }

}
